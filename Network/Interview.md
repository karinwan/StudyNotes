# Network Interview

### OSI 七层模型 和 TCP/IP 四层模型: 

OSI`Open Systems Interconnection`七层模型：

1. _应用层_`Application Layer`：用户`user`与应用`network services`之间的接口`Interfac`（如**HTTP、FTP、SMTP**）。
1. _表示层_`Presentation Layer`：数据格式转换、加密、压缩。
1. _会话层_`Session Layer`：建立、管理、终止会话。
1. 传输层`Transport Layer`：端到端的连接（如**TCP、UDP**）。
1. 网络层`Network Layer`：数据的路由`Routing`（如**IP协议**）。
1. _数据链路层_`Data Link Layer`：数据帧`frame`的传输、错误检测与纠正。
1. _物理层_`Physical Layer`：负责传输原始比特流`raw bits`（如电缆`cable`、光纤`fiber`）。

TCP/IP四层模型：

1. 应用层（对应OSI的应用、表示、会话层）
1. 传输层`Transport Layer `（对应OSI的传输层）
1. 网络层`Internet Layer`（对应OSI的网络层）
1. 网络接口层`Network Access Layer`（对应OSI的物理层和数据链路层）

<img width="360" alt="Screenshot 2025-04-15 at 3 00 56 AM" src="https://github.com/user-attachments/assets/11424a1b-3e99-4149-ac6b-ade748a3ffd7" />

---

### 什么是路由和交换？

路由器`Router`： 工作在**网络层**，根据**IP地址**转发数据包，负责**不同子网或网络**`LAN/WAN`间的通信。

交换机`Switch`： 工作在**数据链路层**，根据**MAC地址**转发**数据帧**，通常用于**局域网内部**的通信。
  - MAC地址`Media Access Control Address`是指网卡在生产时被硬编码的、**全球唯一**的硬件地址，用于在局域网`LAN`中标识设备的身份。

---

### 子网掩码`Subnet Mask`的作用是什么？

- 是一个用来区分 IP 地址中哪一部分是网络地址`network ID`，哪一部分是主机地址`host ID`的值。

- 配合 IP 地址使用，用于判断两个 IP 是否在同一个子网中。只有在同一子网内才能直接通信。否则需要通过路由器。

- 一个 IP 地址实际上包含两个部分：
  - 网络号：你所在的网络范围
  - 主机号：你在网络中的设备编号

  子网掩码决定了前面多少位是网络号，后面多少位是主机号。

  >IP 地址192.168.1.10，转换成二进制：11000000.10101000.00000001.00001010。
  >
  >假设子网掩码是：255.255.255.0，即 11111111.11111111.11111111.00000000，其中`1`表示网络部分`0`表示主机部分。
  >
  >所以网络地址为：192.168.1.0，主机范围为： 192.168.1.1 到 192.168.1.254。
  >
  >常用子网掩码包括：`255.0.0.0`， `255.255.0.0`， `255.255.255.0`
  
---

### 什么是 DNS？如何工作？

- DNS`Domain Name System` 将域名解析为 IP 地址。
- 用户输入网址 → 发送请求至 DNS → 返回对应 IP。

---

### 什么是 IP 地址？IPv4 和 IPv6 区别？

- IPv4： **32** 位，如 `192.168.1.1`，约 43 亿个地址。
- IPv6： **128** 位，如 `2001:0db8:...`，几乎无限。

---

### TCP 三次握手和四次挥手

#### 三次握手
建立一个**可靠连接**前，客户端与服务器之间需要进行**三次通信**来确认彼此状态和准备情况：

1. 客户端发送 `SYN(seq=x)`
   - 客户端发送一个SYN`synchronize`报文段，并携带一个初始序列号`x`，请求建立连接。
2. 服务器回应 `SYN + ACK(seq=y, ack=x+1)`
    - 自己的序列号`y`
    - 对客户端序列号的确认号 `x + 1`
3. 客户端回应 `ACK(ack=y+1)`
   - 客户端收到服务器回应后，发送一个ACK报文段`y + 1`，表示确认服务器的序列号。

为什么需要三次握手？

- 一次握手：客户端发了连接请求，但不知道服务器是否收到。服务器可能已经挂了，网络断了，或者 SYN 丢了，所以不能只靠一次通信建立可靠连接。
- 两次握手：服务器回复了，但客户端可能没有收到（比如断网），此时服务器以为连接建立了，但客户端并不知道，就不会再通信了。于是，服务器一直保持**半连接**`half-open connections`状态，占用资源（称为：SYN Flood 攻击漏洞）。
- 三次握手：客户端告诉服务器：“收到了回应，也准备好了”。服务器这时才真正把连接标记为`ESTABLISHED`状态。
  - 确保了双向通信是可靠的。
  - 防止**半连接占用资源**问题。
 
#### 四次挥手
TCP 连接的断开不是一次完成的，而是通过**四次报文交互**来优雅关闭连接，确保双方都没有数据要发送了。

1. 客户端发送 `FIN`
  - 客户端发送一个FIN`Finish`报文段`FIN = 1`，表示请求关闭连接。
  - 状态变为：`FIN_WAIT_1`
2. 服务器回复 `ACK`
  - 服务器回复报文段`ACK = 1`，表示知晓，在处理过程中。
  - 状态变为：`FIN_WAIT_2`
3. 服务器发送 `FIN`
  - 服务器发送报文段`FIN = 1`，表示准备断开。
  - 状态变为：`LAST_ACK`
4. 客户端回复 `ACK`
  - 客户端进入 `TIME_WAIT` 状态，**等待一段时间**确保服务器收到`ACK`，然后连接彻底关闭。

为什么断开连接需要 4 次？

- 因为 TCP 是**全双工**`Full-duplex`通信，**发送**和**接收**是两个独立的动作，一端关闭发送，不代表对方已经没数据发了。断开连接需要分别关闭两个方向的通道，每个方向都要一个 FIN 和一个 ACK，所以总共需要 4 次挥手。
- 第一次挥手：客户端关闭发送方向。
- 第二次挥手：服务器确认收到，但不是表示 Server 自己也想断。
- 第三次挥手：关闭服务器的发送方向。
- 第四次挥手：客户端确认收到，进入 `TIME_WAIT` 状态，等待可能的重传 `FIN`。
  - 因为网络不可靠，ACK 可能丢。这时服务器会以为你没收到它的 FIN，那么服务器会再次重发 FIN。
  - 如果这时候客户端已经彻底关闭了连接，那这个重复的 FIN 就会被操作系统当作“未知连接”丢弃。
  - 所以客户端需要等待可能的 FIN 重发，然后再重新发一次 ACK，确保连接真正关闭，防止旧连接的数据干扰新连接。
  - 大多数操作系统设置为 1 分钟或 2 分钟。

---

### TCP 和 UDP

| 特性     | TCP 传输控制协议`Transmission Control Protocol` | UDP 用户数据报协议`User Datagram Protocol` |
|----------|---------------------------|--------------------------|
| 连接     | 面向连接：必须先通过“三次握手”建立连接 | 无连接：不需要握手，直接发数据 |
| 可靠性   | 可靠、有序、可重传：丢包会重传，数据顺序会被维护 | 不可靠、无序、不重传：丢包不管，数据顺序不保证 |
| 速度 | 较慢，控制多（流量控制：避免发送方发得太快；拥塞控制：根据网络情况调整速率） | 速度快，开销小 | 
| 数据完整性 | 保证（校验 + 重传），适合传输重要数据 | 不保证，适合 “速度 > 准确” 的实时传输 |
| 应用场景     | 文件传输`FTP`、网页浏览`HTTP/HTTPS`、邮件`SMTP`、数据库连接、登录 | 视频/语音通话、实时直播、游戏、广播 |


#### TCP滑动窗口机制 `Sliding Window`

- TCP 实现**流量控制**的核心机制。
- 允许**未被确认**的数据连续发送，只要窗口大小（单位：字节）允许，减少等待时间。
- 允许动态调整窗口大小，防止拥塞。由接收方通过`ACK`告诉发送方。
- 与**拥塞控制**配合使用：除了接收方的窗口 `rwnd（receiver window）`，还有一个 `cwnd（congestion window`）由**发送方**根据**网络拥塞状态**动态调整。实际窗口大小为`min(rwnd, cwnd)`。

---

### 浏览器输入 URL 后发生了什么？

1. DNS 解析域名
2. 建立 TCP 连接（三次握手）
3. 发出 HTTP 请求
4. 服务器处理并响应
5. 浏览器渲染页面
6. 关闭连接（四次挥手）

---

### HTTP

#### HTTP 版本区别

- **HTTP/0.9：** 只支持 `GET`，无状态码，没有请求头或响应头。
- **HTTP/1.0：** 引入请求头/响应头，每个请求都需要新建一次 TCP 连接（开销大）。
- **HTTP/1.1：** 支持**长连接**和**缓存**，**队头阻塞**问题。（目前仍广泛使用）
- **HTTP/2：** 使用**二进制**格式代替文本，引入**多路复用**（一个连接上同时处理多个请求）、**头部压缩**解决队头阻塞。
- **HTTP/3：** 基于 `UDP/QUIC`，**内置加密**（无需额外 TLS 层），天然避免队头阻塞，更快、更安全、更稳定，适合移动场景与弱网络环境。
  

#### HTTP状态码 `Status code`
- `200 OK`: 成功
- `400 Bad Request`: 错误请求
- `401 Unauthorized`: 未认证
- `403 Forbidden`: 被拒绝
- `404 Not Found`: 未找到
- `500 Internal Server Error`: 服务器内部错误
- `502 Bad Gateway`: 网关错误
- `503 Service Unavailable`: 服务不可用


#### HTTP 参数类型对比

| 属性  | Path 参数 | Query 参数 | Body 参数 | Header 参数 | Cookie 参数 |
|------------------|------------|------------|-------------|-------------|--------------|
| 位置 | URL 路径 `/users/{id}` | URL `?key=value`  | 请求体（JSON/表单/XML）`{ "username": "karin", "password": "123456" }` | 请求头部 `Authorization: Bearer <token>` | Cookie 中 `session_id=abc123` |
| 常用方法 | GET, PUT, DELETE | GET | POST, PUT, PATCH | 所有方法 | 所有方法 |
| 是否暴露在 URL | ✓ | ✓ | X | X | X |
| 用途 | 标识资源 ID | 筛选、搜索、分页 | 提交数据（登录/表单/上传） | 鉴权、语言、内容协商等 | 会话管理、用户追踪 |
| 是否可缓存 | ✓ | ✓ | X | X | ✓（部分情况） |


#### HTTPS

- `HTTPS = HTTP + SSL/TLS` 加密层
- 建立连接时通过 `SSL/TLS` 协议进行握手，客户端验证服务器证书，并用其公钥加密对称密钥，之后双方用对称加密进行通信
- 通过加密通信，保证数据的机密性、完整性和身份认证
- 使用默认端口：**443**
- HTTPS 中的`client_random`和`server_random`是关键组成部分，它们确保每次通信生成的对称密钥都是**唯一**的、**安全**的，并防止**会话重放攻击**。它们虽然**不加密**，但对密钥生成至关重要。

传输流程:

1. 客户端（浏览器）发起请求 `Client Hello`，包括
  - 支持的加密算法列表；
  - 随机数`client_random`；
  - 支持的 TLS 版本；
  - ……
2. 服务器返回 SSL/TLS 证书 `Server Hello`
  - 选定的加密算法;
  - 服务器随机数`server_random`;
  - 服务器的**数字证书**（由 `CA` 签发，包括域名、公钥、签名、过期时间等）;
3. 客户端验证证书
  - 检查证书是否合法（由受信任的 CA 签发、没过期、域名一致）
  - 验证通过后，浏览器生成一个**对称加密密钥**`pre-master key`，用服务器的**公钥**加密发送；
4. 服务器解密密钥
  - 服务器用自己的**私钥**解密出`pre-master key`；
  - 双方用 `client_random + server_random + pre-master` 计算出**会话密钥**`session key/Symmetric Key`；
5. 双方使用对称加密进行安全通信
  - 后续所有通信（请求、响应）都在 `TLS` 层完成加密和完整性校验；
6. 会话结束后，关闭连接或复用连接（`HTTP/2` 支持多路复用）;

`HTTP` 与 `HTTPS` 区别

| 项目       | HTTP               | HTTPS                                 |
|------------|--------------------|----------------------------------------|
| 加密       | 无                 | SSL/TLS 加密                           |
| 端口       | 80                | 443                                    |
| 安全性     | 易被攻击           | 防止窃听、篡改、伪造                    |
| 性能       | 无加密流程         | 加解密略慢                             |
| 应用场景   | 普通网页           | 登录、支付等敏感数据场景               |


#### `GET` 和 `POST` 区别

| 项目           | GET                                  | POST                                 |
|----------------|--------------------------------------|---------------------------------------|
| 用途 | 获取数据（只读） | 提交数据（创建、上传、登录等） |
| 参数传递       | 查询参数`query`，放在 URL 中（如`?id=1&lang=en`） | 放在请求体`Body`中 |
| 安全性         | 低，参数明文显示在地址栏 | 相对更安全高，不容易被看到 |
| 数据量         | 有长度限制（取决于浏览器/服务器） | 几乎无限制，可上传大文件 |
| 幂等性`Idempotent` | 幂等（多次请求结果一样） | 非幂等（多次可能造成重复提交） |
| 缓存/书签支持 | 支持                                | 不支持                                |


#### POST 请求 Body 类型

1. `application/x-www-form-urlencoded`：表单键值对，URL 编码
2. `multipart/form-data`：用于上传文件
3. `application/json`：JSON 格式
4. `text/xml` / `application/xml`：XML 数据
5. `text/plain`：纯文本


#### `Cookie` 与 `Session` 区别

- `Cookie` 是保存在客户端的数据，用于标识用户；`Session` 是保存在服务端的数据，用于管理用户状态。
- `Cookie` 容易被篡改，`Session` 更安全但占服务器资源，两者常结合使用。

| 对比       | Cookie                         | Session                          |
|------------|--------------------------------|----------------------------------|
| **存储位置**     | 客户端（浏览器）                   | 服务端（内存、数据库、缓存）        |
| **存储方式**     | 保存在本地文本文件中               | 通常通过 Session ID 映射存储对象     |
| **是否安全**     | 安全性低，易被窃听或篡改           | 安全性高，数据不会暴露给客户端       |
| **依赖客户端？** | 是，用户可禁用 Cookie              | 否，只需依赖浏览器支持 Cookie 即可   |
| **生命周期**     | 可设置过期时间，或随浏览器关闭失效 | 浏览器关闭或超时后失效               |
| **主要作用**     | 保存用户偏好、身份令牌等轻量信息   | 管理用户会话状态，如登录信息         |
| **是否可被修改** | 可以被用户查看、修改甚至伪造       | 仅服务端可修改                       |
| **占服务器资源** | 不占资源                           | 占用服务端资源（尤其高并发下）       |
| **典型用途**     | “记住我”功能、语言设置             | 登录状态管理、购物流程跟踪           |

协作方式
1. 用户登录时，服务器创建一个 Session，记录用户状态；
2. 服务器生成一个 `Session ID`，并写入到 Cookie 返回给客户端；
3. 浏览器保存这个 Cookie（比如 `session_id=abc123`），客户端后续请求自动携带这个 Cookie；
4. 服务端通过 `Session ID` 找回对应用户数据，实现会话管理。

---

### 常见网络攻击及防御

攻击方式：
- **DDoS**：**恶意流量**压垮服务器；
- **中间人攻击**`MITM`：数据被**截获/篡改**；
- **SQL 注入**：恶意 SQL 操作数据库；

防御手段：
- 加密通信、IDS（入侵检测系统）
- 使用 Prepared Statement 防 SQL 注入

